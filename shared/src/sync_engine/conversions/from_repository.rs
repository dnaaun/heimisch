use crate::{
    avail::{Avail, MergeError}, sync_engine::changes::{AddChanges, Changes}, types::{
        installation::InstallationId,
        repository::RepositoryId,
    }
};

use super::{from_license::from_license, from_user2::from_user2};

pub fn from_repository(
    api_repo: github_api::models::Repository,
    installation_id: InstallationId,
) -> Result<(RepositoryId, Changes), MergeError> {
    let github_api::models::Repository {
        allow_auto_merge,
        allow_forking,
        allow_merge_commit,
        allow_rebase_merge,
        allow_squash_merge,
        allow_update_branch,
        archive_url,
        archived,
        assignees_url,
        blobs_url,
        branches_url,
        clone_url,
        collaborators_url,
        comments_url,
        commits_url,
        compare_url,
        contents_url,
        contributors_url,
        created_at,
        default_branch,
        delete_branch_on_merge,
        deployments_url,
        description,
        disabled,
        downloads_url,
        events_url,
        fork,
        forks,
        forks_count,
        forks_url,
        full_name,
        git_commits_url,
        git_refs_url,
        git_tags_url,
        git_url,
        has_downloads,
        has_issues,
        has_pages,
        has_projects,
        has_wiki,
        has_discussions,
        homepage,
        hooks_url,
        html_url,
        id,
        is_template,
        issue_comment_url,
        issue_events_url,
        issues_url,
        keys_url,
        labels_url,
        language,
        languages_url,
        license,
        master_branch,
        merge_commit_message,
        merge_commit_title,
        merges_url,
        milestones_url,
        mirror_url,
        name,
        node_id,
        notifications_url,
        open_issues,
        open_issues_count,
        organization,
        owner,
        permissions,
        private,
        public: _, // Why have a flag for both public and private?
        pulls_url,
        pushed_at,
        releases_url,
        role_name,
        size,
        squash_merge_commit_message,
        squash_merge_commit_title,
        ssh_url,
        stargazers: _, // Not sure why we need both stargazers and stargazers_count
        stargazers_count,
        stargazers_url,
        statuses_url,
        subscribers_url,
        subscription_url,
        svn_url,
        tags_url,
        teams_url,
        topics,
        trees_url,
        updated_at,
        url,
        use_squash_pr_title_as_default,
        visibility,
        watchers,
        watchers_count,
        web_commit_signoff_required,
    } = api_repo;

    let db_owner = owner.map(|i| from_user2(*i));
    let db_license = license.map(|l| from_license(*l));

    let db_repo = crate::types::repository::Repository {
        allow_auto_merge: Avail::from_option(allow_auto_merge),
        allow_forking: allow_forking.into(),
        allow_merge_commit: Avail::from_option(allow_merge_commit),
        allow_rebase_merge: Avail::from_option(allow_rebase_merge),
        allow_squash_merge: Avail::from_option(allow_squash_merge),
        allow_update_branch: Avail::from_option(allow_update_branch),
        anonymous_access_enabled: Avail::No,
        archive_url: archive_url.into(),
        archived: archived.into(),
        assignees_url: assignees_url.into(),
        blobs_url: blobs_url.into(),
        branches_url: branches_url.into(),
        clone_url: clone_url.into(),
        collaborators_url: collaborators_url.into(),
        comments_url: comments_url.into(),
        commits_url: commits_url.into(),
        compare_url: compare_url.into(),
        contents_url: contents_url.into(),
        contributors_url: contributors_url.into(),
        created_at: Avail::from_option(created_at),
        default_branch: default_branch.into(),
        delete_branch_on_merge: Avail::from_option(delete_branch_on_merge),
        deployments_url: deployments_url.into(),
        description: description.into(),
        disabled: Avail::from_option(disabled),
        downloads_url: downloads_url.into(),
        events_url: events_url.into(),
        fork: fork.into(),
        forks: i64::from(forks).into(),
        forks_count: i64::from(forks_count).into(),
        forks_url: forks_url.into(),
        full_name: full_name.into(),
        git_commits_url: git_commits_url.into(),
        git_refs_url: git_refs_url.into(),
        git_tags_url: git_tags_url.into(),
        git_url: git_url.into(),
        has_discussions: has_discussions.into(),
        has_downloads: has_downloads.into(),
        has_issues: has_issues.into(),
        has_pages: has_pages.into(),
        has_projects: has_projects.into(),
        has_wiki: has_wiki.into(),
        homepage: homepage.into(),
        hooks_url: hooks_url.into(),
        html_url: html_url.into(),
        id: id.into(),
        is_template: Avail::from_option(is_template),
        issue_comment_url: issue_comment_url.into(),
        issue_events_url: issue_events_url.into(),
        issues_url: issues_url.into(),
        keys_url: keys_url.into(),
        labels_url: labels_url.into(),
        language: language.into(),
        languages_url: languages_url.into(),
        license_id: db_license.as_ref().map(|l| l.key.clone()).into(),
        master_branch: master_branch.into(),
        merge_commit_message: merge_commit_message.into(),
        merge_commit_title: merge_commit_title.into(),
        merges_url: merges_url.into(),
        milestones_url: milestones_url.into(),
        mirror_url: mirror_url.into(),
        name: name.into(),
        node_id: node_id.into(),
        notifications_url: notifications_url.into(),
        open_issues: i64::from(open_issues).into(),
        open_issues_count: i64::from(open_issues_count).into(),
        owner_id: match &db_owner {
            Some(db_owner) => db_owner.id.clone().into(),
            None => Avail::No,
        },
        organization: organization.into(),
        permissions: permissions.map(|i| *i).into(),
        private: private.into(),
        pulls_url: pulls_url.into(),
        pushed_at: pushed_at.into(),
        releases_url: releases_url.into(),
        role_name: Avail::from_option(role_name),
        size: i64::from(size).into(),
        squash_merge_commit_message: squash_merge_commit_message.into(),
        squash_merge_commit_title: squash_merge_commit_title.into(),
        ssh_url: ssh_url.into(),
        stargazers_count: i64::from(stargazers_count).into(),
        stargazers_url: stargazers_url.into(),
        starred_at: Avail::No,
        statuses_url: statuses_url.into(),
        subscribers_url: subscribers_url.into(),
        subscription_url: subscription_url.into(),
        svn_url: svn_url.into(),
        tags_url: tags_url.into(),
        teams_url: teams_url.into(),
        temp_clone_token: Avail::No,
        topics: topics.into(),
        trees_url: trees_url.into(),
        updated_at: updated_at.into(),
        url: url.into(),
        use_squash_pr_title_as_default: Avail::from_option(use_squash_pr_title_as_default),
        visibility: visibility.into(),
        watchers: i64::from(watchers).into(),
        watchers_count: i64::from(watchers_count).into(),
        web_commit_signoff_required: Avail::from_option(web_commit_signoff_required),
        installation_id: installation_id.into(),
    };

    let id = db_repo.id;

    let mut changes = Changes::default();
    changes.add(db_owner)?;
    changes.add(db_license)?;
    changes.add(db_repo)?;

    Ok((id, changes))
}
